---
title: 3/8 栈和队列
date: 2021-12-21 21:50:00
tags:
categories: 《数据结构与算法》
cover: Untitled.png
---

# 3.1 栈和队列的定义和特点

> 栈和队列是限定插入和删除只能在表的**端点**进行的**线性表**，是线性表的**子集**
> 

## 3.1.1 栈：Stack

栈就像手电筒装电池、手枪弹夹里装子弹：有**后进先出（Last In First Out）**的特性

- 栈是仅在**表尾**进行插入删除操作的线性表，简称**LIFO结构**
- 它与一般线性表的区别：**仅在于运算规则不同**

![](Untitled.png)

- 案例1：进制转换

![](Untitled%201.png)

- 括号匹配的检验

![](Untitled%202.png)

- 表达式求值

![](Untitled%203.png)

## 3.1.2 队列Queue

队列就像排队，有**先进先出（First In First Out）**的特性，插入仅在表尾，删除仅在表头  

- 舞伴问题

![](Untitled%204.png)

# 3.3 栈的定义和实现：顺序栈和链栈

![](Untitled%205.png)

![](Untitled%206.png)

## 3.3.2 顺序栈的实现

![](Untitled%207.png)

![](Untitled%208.png)

- 上溢(overflow):栈已经满，又要压入元素，使问题的处理无法进行
- 下溢(underflow):栈已经空，还要弹出元素，只认为是一种结束条件

![](Untitled%209.png)

![](Untitled%2010.png)

- 顺序栈的长度=S.top-S.base，这里可以对指针加减，他会自动除以元素长度

- 删除时，删除base对应空间，长度设为0，两个指针设为空
- 入栈：先判断是否上溢，满则报错(也可以加空间），否则压入元素并让top加1
*S.top=e; S.top++;或者*S.top++=e;
- 出栈：先判断是否下溢，满则报错(也可以加空间）,否则获取元素出栈并让top-1
e=*- -S.top

## 3.3.2 链栈的实现

- 链栈是**运算受限**的单链表，只能在**链表头部**进行操作
- 注意链栈中指针的方向
链表的头指针就是栈顶
不需要头结点
基本不存在栈满的情况
**空栈相当于头指针指向空**
插入和删除仅在栈顶处执行

![](Untitled%2011.png)

![](Untitled%2012.png)

![](Untitled%2013.png)

# 3.4 栈与递归

![](Untitled%2014.png)

![](Untitled%2015.png)

![](Untitled%2016.png)

# 3.5 队列的表示和操作

凡是涉及使用有限资源，一切要用到排队的东西都要用到队列

![](Untitled%2017.png)

## 3.5.1 顺序队列/队列的顺序表示

- 注意此处头指针和尾指针都是int型

![](Untitled%2018.png)

![](Untitled%2019.png)

![](Untitled%2020.png)

- 解决假上溢的方法：将队空间设想成一个循环的表，即分配给队列的m个存储单元可以循环使用，当rear为maxqsize时，若向量的开始端空着，又可从头使用空着的空间。当front为maxqsize时,也是一样。——循环队列

![](Untitled%2021.png)

如何判断真假上溢？如何判断队列满了？
1.另外设一个标志以区别队空、队满
2.另设一个变量，记录元素个数
**3.少用一个元素空间**

![](Untitled%2022.png)

## 3.5.2 循环顺序队列

![](Untitled%2023.png)

<aside>
📌 因为我们采用了少用一个元素空间的方法来帮助判断真假上溢。则开辟了MaxQsize个元素的空间时，实际只使用MaxQsize-1个。下方计算长度的公式仍然成立，MaxQsize就是指最大空间数。

</aside>

![](Untitled%2024.png)

上文已经介绍了循环队列如何入队和出队，但记住额外判断队列是满还是空 

## 3.5.3 链式队列

![](Untitled%2025.png)

<aside>
📌 将链栈/链式队列与正常单链表对比：
1.封装等级：第一层定义ELemType类型，第二次定义Node类型，但是链式队列要更高一次，用两个指针专门为结点链接起来的链表确认首尾，指向结点；
2.有无头结点：链栈没有，其他两者有；
3.指针方向：链栈的方向是反过来的，结点元素内的next指针指向前一个元素；

</aside>

- 入队不用考虑上溢，出队要考虑下溢，同时如果出队的最后一个元素，还要额外修改尾指针

![](Untitled%2026.png)

![](Untitled%2027.png)