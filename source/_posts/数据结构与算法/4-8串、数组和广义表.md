---
title: 4/8 串、数组和广义表
date: 2021-12-26 10:45:00
tags:
categories: 《数据结构与算法》
cover: Untitled.png
---
# 4.1 串：内容受限的线性表

> 串（String）——零个或多个任意字符组成的有限序列
> 

![](Untitled.png)

![](Untitled%201.png)

## 4.1.1串的顺序存储结构（更常用）

![](Untitled%202.png)

## 4.1.2串的链式存储结构——块链结构

![](Untitled%203.png)

![](Untitled%204.png)

## 4.1.4 串的模式匹配算法

- 目的：确定主串中所含子串第一次出现的位置

### **Brute—Force算法，亦称简单匹配算法：穷举**

![](Untitled%205.png)

BF算法的时间复杂度
最好的情况是比较m次，最差为(n-m+1)*m次，效率低

![](Untitled%206.png)

### **KMP算法设计思想**

1. 此时主串的指针i不必回溯！
2. 假设某时刻已经比较到子串的前(j-1)位和主串第i位前面的(j-1)位已经相等了，但是i，j本身不相等；
3. 此时寻找主串第i位前面有没有(k-1)位和子串从头开始的前(k-1)位正好相等；
4. 如果没有，子串第一位和主串第i位继续往后比；
5. 如果有，那么主串的第i位和子串的第k位继续往后比；
6. 如此做直到找到或者主串比完了；

<aside>
📌 第三步中，因为主串前(j-1)位已经和子串前(j-1)位相等了，所以要确定下一次从子串的哪一位开始继续比，只要看子串的前(k-1)位和第j位前的(k-1)位就可以了。则定义了next[j]这样一个函数处理子串

强调一下1<k<j。其实next[2]=1是一定的，符合下方函数展开的第一种形式。因为子串的第一位一定和第二位前的一位相等，集合时非空的，按理来说k=2。但本身就是因为第二位不匹配才想使用next移动位置，所以不能让其等于2。或者说小于j就派出了“前面所有等于前面所有”的情况。

</aside>

![](Untitled%207.png)

这里相当于用下面这个函数把子串要用到的所有next[j]等于多少算出来，记录在next数组里了。

ps:这段代码妙不可言！~~

![](Untitled%208.png)

 整合之后：

![](Untitled%209.png)

对next进行改进：

![](Untitled%2010.png)

将指针从j移到前面的next[j]了，但是原来第j位已经确定和主串不相等了，如果第j位和第next[j]位相等，肯定也不和主串相等。所以继续前移到next[next[j]]的位置，继续和第j位相比直到不等为止。

![](Untitled%2011.png)

# 4.2 数组

> 数组：按一定格式排列起来的具有相同类型的数据元素的集合(一般用顺序结构)
> 

int num[5]={1,2,3,4,5};

int num[5][8];//五行八列的数组

![](Untitled%2012.png)

![](Untitled%2013.png)

## 4.2.1 特殊矩阵的压缩存储

![](Untitled%2014.png)

![](Untitled%2015.png)

![](Untitled%2016.png)

![](Untitled%2017.png)

![](Untitled%2018.png)

链式存储稀疏矩阵——十字链表：

![](Untitled%2019.png)

# 4.3 广义表

> 广义表(又称列表Lists)是n≥0个元素a0, a1, .... ,an-1的有限序列，其中每一个ai或者是原子，或者是一个广义表。
> 

![](Untitled%2020.png)

![](Untitled%2021.png)

![](Untitled%2022.png)

![](Untitled%2023.png)